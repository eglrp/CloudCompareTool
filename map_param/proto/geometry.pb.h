// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: geometry.proto

#ifndef PROTOBUF_geometry_2eproto__INCLUDED
#define PROTOBUF_geometry_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "id.pb.h"
// @@protoc_insertion_point(includes)

namespace hdmap_proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_geometry_2eproto();
void protobuf_AssignDesc_geometry_2eproto();
void protobuf_ShutdownFile_geometry_2eproto();

class Point;
class Normal;
class LineSegment;
class Cylinder;
class Circle;
class PolyLine;
class Rect;
class Cube;
class Polygon;
class CurveControl;
class Curve;
class ParkingSlot;

// ===================================================================

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:hdmap_proto.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Normal : public ::google::protobuf::Message {
 public:
  Normal();
  virtual ~Normal();

  Normal(const Normal& from);

  inline Normal& operator=(const Normal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Normal& default_instance();

  void Swap(Normal* other);

  // implements Message ----------------------------------------------

  Normal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Normal& from);
  void MergeFrom(const Normal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:hdmap_proto.Normal)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Normal* default_instance_;
};
// -------------------------------------------------------------------

class LineSegment : public ::google::protobuf::Message {
 public:
  LineSegment();
  virtual ~LineSegment();

  LineSegment(const LineSegment& from);

  inline LineSegment& operator=(const LineSegment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineSegment& default_instance();

  void Swap(LineSegment* other);

  // implements Message ----------------------------------------------

  LineSegment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineSegment& from);
  void MergeFrom(const LineSegment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hdmap_proto.Point start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::hdmap_proto::Point& start() const;
  inline ::hdmap_proto::Point* mutable_start();
  inline ::hdmap_proto::Point* release_start();
  inline void set_allocated_start(::hdmap_proto::Point* start);

  // required .hdmap_proto.Point end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline const ::hdmap_proto::Point& end() const;
  inline ::hdmap_proto::Point* mutable_end();
  inline ::hdmap_proto::Point* release_end();
  inline void set_allocated_end(::hdmap_proto::Point* end);

  // @@protoc_insertion_point(class_scope:hdmap_proto.LineSegment)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hdmap_proto::Point* start_;
  ::hdmap_proto::Point* end_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static LineSegment* default_instance_;
};
// -------------------------------------------------------------------

class Cylinder : public ::google::protobuf::Message {
 public:
  Cylinder();
  virtual ~Cylinder();

  Cylinder(const Cylinder& from);

  inline Cylinder& operator=(const Cylinder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cylinder& default_instance();

  void Swap(Cylinder* other);

  // implements Message ----------------------------------------------

  Cylinder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cylinder& from);
  void MergeFrom(const Cylinder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hdmap_proto.LineSegment line = 1;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 1;
  inline const ::hdmap_proto::LineSegment& line() const;
  inline ::hdmap_proto::LineSegment* mutable_line();
  inline ::hdmap_proto::LineSegment* release_line();
  inline void set_allocated_line(::hdmap_proto::LineSegment* line);

  // required float radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline float radius() const;
  inline void set_radius(float value);

  // @@protoc_insertion_point(class_scope:hdmap_proto.Cylinder)
 private:
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hdmap_proto::LineSegment* line_;
  float radius_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Cylinder* default_instance_;
};
// -------------------------------------------------------------------

class Circle : public ::google::protobuf::Message {
 public:
  Circle();
  virtual ~Circle();

  Circle(const Circle& from);

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Circle& default_instance();

  void Swap(Circle* other);

  // implements Message ----------------------------------------------

  Circle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Circle& from);
  void MergeFrom(const Circle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hdmap_proto.Point center = 1;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 1;
  inline const ::hdmap_proto::Point& center() const;
  inline ::hdmap_proto::Point* mutable_center();
  inline ::hdmap_proto::Point* release_center();
  inline void set_allocated_center(::hdmap_proto::Point* center);

  // required .hdmap_proto.Normal normal = 2;
  inline bool has_normal() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 2;
  inline const ::hdmap_proto::Normal& normal() const;
  inline ::hdmap_proto::Normal* mutable_normal();
  inline ::hdmap_proto::Normal* release_normal();
  inline void set_allocated_normal(::hdmap_proto::Normal* normal);

  // required float radius = 3;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 3;
  inline float radius() const;
  inline void set_radius(float value);

  // @@protoc_insertion_point(class_scope:hdmap_proto.Circle)
 private:
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_normal();
  inline void clear_has_normal();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hdmap_proto::Point* center_;
  ::hdmap_proto::Normal* normal_;
  float radius_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Circle* default_instance_;
};
// -------------------------------------------------------------------

class PolyLine : public ::google::protobuf::Message {
 public:
  PolyLine();
  virtual ~PolyLine();

  PolyLine(const PolyLine& from);

  inline PolyLine& operator=(const PolyLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PolyLine& default_instance();

  void Swap(PolyLine* other);

  // implements Message ----------------------------------------------

  PolyLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PolyLine& from);
  void MergeFrom(const PolyLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hdmap_proto.Point points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::hdmap_proto::Point& points(int index) const;
  inline ::hdmap_proto::Point* mutable_points(int index);
  inline ::hdmap_proto::Point* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:hdmap_proto.PolyLine)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point > points_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static PolyLine* default_instance_;
};
// -------------------------------------------------------------------

class Rect : public ::google::protobuf::Message {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rect& default_instance();

  void Swap(Rect* other);

  // implements Message ----------------------------------------------

  Rect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hdmap_proto.Point points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::hdmap_proto::Point& points(int index) const;
  inline ::hdmap_proto::Point* mutable_points(int index);
  inline ::hdmap_proto::Point* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:hdmap_proto.Rect)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point > points_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Rect* default_instance_;
};
// -------------------------------------------------------------------

class Cube : public ::google::protobuf::Message {
 public:
  Cube();
  virtual ~Cube();

  Cube(const Cube& from);

  inline Cube& operator=(const Cube& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cube& default_instance();

  void Swap(Cube* other);

  // implements Message ----------------------------------------------

  Cube* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cube& from);
  void MergeFrom(const Cube& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hdmap_proto.Point points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::hdmap_proto::Point& points(int index) const;
  inline ::hdmap_proto::Point* mutable_points(int index);
  inline ::hdmap_proto::Point* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:hdmap_proto.Cube)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point > points_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Cube* default_instance_;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  void Swap(Polygon* other);

  // implements Message ----------------------------------------------

  Polygon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hdmap_proto.Point points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::hdmap_proto::Point& points(int index) const;
  inline ::hdmap_proto::Point* mutable_points(int index);
  inline ::hdmap_proto::Point* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:hdmap_proto.Polygon)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point > points_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Polygon* default_instance_;
};
// -------------------------------------------------------------------

class CurveControl : public ::google::protobuf::Message {
 public:
  CurveControl();
  virtual ~CurveControl();

  CurveControl(const CurveControl& from);

  inline CurveControl& operator=(const CurveControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurveControl& default_instance();

  void Swap(CurveControl* other);

  // implements Message ----------------------------------------------

  CurveControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurveControl& from);
  void MergeFrom(const CurveControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hdmap_proto.Point point = 1;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::hdmap_proto::Point& point() const;
  inline ::hdmap_proto::Point* mutable_point();
  inline ::hdmap_proto::Point* release_point();
  inline void set_allocated_point(::hdmap_proto::Point* point);

  // required .hdmap_proto.Point pre_point = 2;
  inline bool has_pre_point() const;
  inline void clear_pre_point();
  static const int kPrePointFieldNumber = 2;
  inline const ::hdmap_proto::Point& pre_point() const;
  inline ::hdmap_proto::Point* mutable_pre_point();
  inline ::hdmap_proto::Point* release_pre_point();
  inline void set_allocated_pre_point(::hdmap_proto::Point* pre_point);

  // required .hdmap_proto.Point suc_point = 3;
  inline bool has_suc_point() const;
  inline void clear_suc_point();
  static const int kSucPointFieldNumber = 3;
  inline const ::hdmap_proto::Point& suc_point() const;
  inline ::hdmap_proto::Point* mutable_suc_point();
  inline ::hdmap_proto::Point* release_suc_point();
  inline void set_allocated_suc_point(::hdmap_proto::Point* suc_point);

  // @@protoc_insertion_point(class_scope:hdmap_proto.CurveControl)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_pre_point();
  inline void clear_has_pre_point();
  inline void set_has_suc_point();
  inline void clear_has_suc_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hdmap_proto::Point* point_;
  ::hdmap_proto::Point* pre_point_;
  ::hdmap_proto::Point* suc_point_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static CurveControl* default_instance_;
};
// -------------------------------------------------------------------

class Curve : public ::google::protobuf::Message {
 public:
  Curve();
  virtual ~Curve();

  Curve(const Curve& from);

  inline Curve& operator=(const Curve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Curve& default_instance();

  void Swap(Curve* other);

  // implements Message ----------------------------------------------

  Curve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Curve& from);
  void MergeFrom(const Curve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hdmap_proto.CurveControl controls = 1;
  inline int controls_size() const;
  inline void clear_controls();
  static const int kControlsFieldNumber = 1;
  inline const ::hdmap_proto::CurveControl& controls(int index) const;
  inline ::hdmap_proto::CurveControl* mutable_controls(int index);
  inline ::hdmap_proto::CurveControl* add_controls();
  inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::CurveControl >&
      controls() const;
  inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::CurveControl >*
      mutable_controls();

  // @@protoc_insertion_point(class_scope:hdmap_proto.Curve)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hdmap_proto::CurveControl > controls_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static Curve* default_instance_;
};
// -------------------------------------------------------------------

class ParkingSlot : public ::google::protobuf::Message {
 public:
  ParkingSlot();
  virtual ~ParkingSlot();

  ParkingSlot(const ParkingSlot& from);

  inline ParkingSlot& operator=(const ParkingSlot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSlot& default_instance();

  void Swap(ParkingSlot* other);

  // implements Message ----------------------------------------------

  ParkingSlot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParkingSlot& from);
  void MergeFrom(const ParkingSlot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hdmap_proto.Id id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::hdmap_proto::Id& id() const;
  inline ::hdmap_proto::Id* mutable_id();
  inline ::hdmap_proto::Id* release_id();
  inline void set_allocated_id(::hdmap_proto::Id* id);

  // required .hdmap_proto.Polygon polygon = 2;
  inline bool has_polygon() const;
  inline void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  inline const ::hdmap_proto::Polygon& polygon() const;
  inline ::hdmap_proto::Polygon* mutable_polygon();
  inline ::hdmap_proto::Polygon* release_polygon();
  inline void set_allocated_polygon(::hdmap_proto::Polygon* polygon);

  // repeated .hdmap_proto.Id link_ids = 3;
  inline int link_ids_size() const;
  inline void clear_link_ids();
  static const int kLinkIdsFieldNumber = 3;
  inline const ::hdmap_proto::Id& link_ids(int index) const;
  inline ::hdmap_proto::Id* mutable_link_ids(int index);
  inline ::hdmap_proto::Id* add_link_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Id >&
      link_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Id >*
      mutable_link_ids();

  // @@protoc_insertion_point(class_scope:hdmap_proto.ParkingSlot)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_polygon();
  inline void clear_has_polygon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hdmap_proto::Id* id_;
  ::hdmap_proto::Polygon* polygon_;
  ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Id > link_ids_;
  friend void  protobuf_AddDesc_geometry_2eproto();
  friend void protobuf_AssignDesc_geometry_2eproto();
  friend void protobuf_ShutdownFile_geometry_2eproto();

  void InitAsDefaultInstance();
  static ParkingSlot* default_instance_;
};
// ===================================================================


// ===================================================================

// Point

// required double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:hdmap_proto.Point.x)
}

// required double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:hdmap_proto.Point.y)
}

// required double z = 3;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Point.z)
  return z_;
}
inline void Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:hdmap_proto.Point.z)
}

// -------------------------------------------------------------------

// Normal

// required float x = 1;
inline bool Normal::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Normal::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Normal::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Normal::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Normal::x() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Normal.x)
  return x_;
}
inline void Normal::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:hdmap_proto.Normal.x)
}

// required float y = 2;
inline bool Normal::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Normal::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Normal::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Normal::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Normal::y() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Normal.y)
  return y_;
}
inline void Normal::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:hdmap_proto.Normal.y)
}

// required float z = 3;
inline bool Normal::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Normal::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Normal::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Normal::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Normal::z() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Normal.z)
  return z_;
}
inline void Normal::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:hdmap_proto.Normal.z)
}

// -------------------------------------------------------------------

// LineSegment

// required .hdmap_proto.Point start = 1;
inline bool LineSegment::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineSegment::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineSegment::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineSegment::clear_start() {
  if (start_ != NULL) start_->::hdmap_proto::Point::Clear();
  clear_has_start();
}
inline const ::hdmap_proto::Point& LineSegment::start() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.LineSegment.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::hdmap_proto::Point* LineSegment::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::hdmap_proto::Point;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.LineSegment.start)
  return start_;
}
inline ::hdmap_proto::Point* LineSegment::release_start() {
  clear_has_start();
  ::hdmap_proto::Point* temp = start_;
  start_ = NULL;
  return temp;
}
inline void LineSegment::set_allocated_start(::hdmap_proto::Point* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.LineSegment.start)
}

// required .hdmap_proto.Point end = 2;
inline bool LineSegment::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineSegment::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineSegment::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineSegment::clear_end() {
  if (end_ != NULL) end_->::hdmap_proto::Point::Clear();
  clear_has_end();
}
inline const ::hdmap_proto::Point& LineSegment::end() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.LineSegment.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::hdmap_proto::Point* LineSegment::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::hdmap_proto::Point;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.LineSegment.end)
  return end_;
}
inline ::hdmap_proto::Point* LineSegment::release_end() {
  clear_has_end();
  ::hdmap_proto::Point* temp = end_;
  end_ = NULL;
  return temp;
}
inline void LineSegment::set_allocated_end(::hdmap_proto::Point* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.LineSegment.end)
}

// -------------------------------------------------------------------

// Cylinder

// required .hdmap_proto.LineSegment line = 1;
inline bool Cylinder::has_line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cylinder::set_has_line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cylinder::clear_has_line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cylinder::clear_line() {
  if (line_ != NULL) line_->::hdmap_proto::LineSegment::Clear();
  clear_has_line();
}
inline const ::hdmap_proto::LineSegment& Cylinder::line() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Cylinder.line)
  return line_ != NULL ? *line_ : *default_instance_->line_;
}
inline ::hdmap_proto::LineSegment* Cylinder::mutable_line() {
  set_has_line();
  if (line_ == NULL) line_ = new ::hdmap_proto::LineSegment;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.Cylinder.line)
  return line_;
}
inline ::hdmap_proto::LineSegment* Cylinder::release_line() {
  clear_has_line();
  ::hdmap_proto::LineSegment* temp = line_;
  line_ = NULL;
  return temp;
}
inline void Cylinder::set_allocated_line(::hdmap_proto::LineSegment* line) {
  delete line_;
  line_ = line;
  if (line) {
    set_has_line();
  } else {
    clear_has_line();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.Cylinder.line)
}

// required float radius = 2;
inline bool Cylinder::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cylinder::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cylinder::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cylinder::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float Cylinder::radius() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Cylinder.radius)
  return radius_;
}
inline void Cylinder::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:hdmap_proto.Cylinder.radius)
}

// -------------------------------------------------------------------

// Circle

// required .hdmap_proto.Point center = 1;
inline bool Circle::has_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Circle::set_has_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Circle::clear_has_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Circle::clear_center() {
  if (center_ != NULL) center_->::hdmap_proto::Point::Clear();
  clear_has_center();
}
inline const ::hdmap_proto::Point& Circle::center() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Circle.center)
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::hdmap_proto::Point* Circle::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::hdmap_proto::Point;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.Circle.center)
  return center_;
}
inline ::hdmap_proto::Point* Circle::release_center() {
  clear_has_center();
  ::hdmap_proto::Point* temp = center_;
  center_ = NULL;
  return temp;
}
inline void Circle::set_allocated_center(::hdmap_proto::Point* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.Circle.center)
}

// required .hdmap_proto.Normal normal = 2;
inline bool Circle::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Circle::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Circle::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Circle::clear_normal() {
  if (normal_ != NULL) normal_->::hdmap_proto::Normal::Clear();
  clear_has_normal();
}
inline const ::hdmap_proto::Normal& Circle::normal() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Circle.normal)
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
inline ::hdmap_proto::Normal* Circle::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) normal_ = new ::hdmap_proto::Normal;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.Circle.normal)
  return normal_;
}
inline ::hdmap_proto::Normal* Circle::release_normal() {
  clear_has_normal();
  ::hdmap_proto::Normal* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void Circle::set_allocated_normal(::hdmap_proto::Normal* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.Circle.normal)
}

// required float radius = 3;
inline bool Circle::has_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Circle::set_has_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Circle::clear_has_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Circle::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float Circle::radius() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Circle.radius)
  return radius_;
}
inline void Circle::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:hdmap_proto.Circle.radius)
}

// -------------------------------------------------------------------

// PolyLine

// repeated .hdmap_proto.Point points = 1;
inline int PolyLine::points_size() const {
  return points_.size();
}
inline void PolyLine::clear_points() {
  points_.Clear();
}
inline const ::hdmap_proto::Point& PolyLine::points(int index) const {
  // @@protoc_insertion_point(field_get:hdmap_proto.PolyLine.points)
  return points_.Get(index);
}
inline ::hdmap_proto::Point* PolyLine::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:hdmap_proto.PolyLine.points)
  return points_.Mutable(index);
}
inline ::hdmap_proto::Point* PolyLine::add_points() {
  // @@protoc_insertion_point(field_add:hdmap_proto.PolyLine.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >&
PolyLine::points() const {
  // @@protoc_insertion_point(field_list:hdmap_proto.PolyLine.points)
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >*
PolyLine::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:hdmap_proto.PolyLine.points)
  return &points_;
}

// -------------------------------------------------------------------

// Rect

// repeated .hdmap_proto.Point points = 1;
inline int Rect::points_size() const {
  return points_.size();
}
inline void Rect::clear_points() {
  points_.Clear();
}
inline const ::hdmap_proto::Point& Rect::points(int index) const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Rect.points)
  return points_.Get(index);
}
inline ::hdmap_proto::Point* Rect::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:hdmap_proto.Rect.points)
  return points_.Mutable(index);
}
inline ::hdmap_proto::Point* Rect::add_points() {
  // @@protoc_insertion_point(field_add:hdmap_proto.Rect.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >&
Rect::points() const {
  // @@protoc_insertion_point(field_list:hdmap_proto.Rect.points)
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >*
Rect::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:hdmap_proto.Rect.points)
  return &points_;
}

// -------------------------------------------------------------------

// Cube

// repeated .hdmap_proto.Point points = 1;
inline int Cube::points_size() const {
  return points_.size();
}
inline void Cube::clear_points() {
  points_.Clear();
}
inline const ::hdmap_proto::Point& Cube::points(int index) const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Cube.points)
  return points_.Get(index);
}
inline ::hdmap_proto::Point* Cube::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:hdmap_proto.Cube.points)
  return points_.Mutable(index);
}
inline ::hdmap_proto::Point* Cube::add_points() {
  // @@protoc_insertion_point(field_add:hdmap_proto.Cube.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >&
Cube::points() const {
  // @@protoc_insertion_point(field_list:hdmap_proto.Cube.points)
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >*
Cube::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:hdmap_proto.Cube.points)
  return &points_;
}

// -------------------------------------------------------------------

// Polygon

// repeated .hdmap_proto.Point points = 1;
inline int Polygon::points_size() const {
  return points_.size();
}
inline void Polygon::clear_points() {
  points_.Clear();
}
inline const ::hdmap_proto::Point& Polygon::points(int index) const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Polygon.points)
  return points_.Get(index);
}
inline ::hdmap_proto::Point* Polygon::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:hdmap_proto.Polygon.points)
  return points_.Mutable(index);
}
inline ::hdmap_proto::Point* Polygon::add_points() {
  // @@protoc_insertion_point(field_add:hdmap_proto.Polygon.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >&
Polygon::points() const {
  // @@protoc_insertion_point(field_list:hdmap_proto.Polygon.points)
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Point >*
Polygon::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:hdmap_proto.Polygon.points)
  return &points_;
}

// -------------------------------------------------------------------

// CurveControl

// required .hdmap_proto.Point point = 1;
inline bool CurveControl::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurveControl::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurveControl::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurveControl::clear_point() {
  if (point_ != NULL) point_->::hdmap_proto::Point::Clear();
  clear_has_point();
}
inline const ::hdmap_proto::Point& CurveControl::point() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.CurveControl.point)
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::hdmap_proto::Point* CurveControl::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::hdmap_proto::Point;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.CurveControl.point)
  return point_;
}
inline ::hdmap_proto::Point* CurveControl::release_point() {
  clear_has_point();
  ::hdmap_proto::Point* temp = point_;
  point_ = NULL;
  return temp;
}
inline void CurveControl::set_allocated_point(::hdmap_proto::Point* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.CurveControl.point)
}

// required .hdmap_proto.Point pre_point = 2;
inline bool CurveControl::has_pre_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurveControl::set_has_pre_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurveControl::clear_has_pre_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurveControl::clear_pre_point() {
  if (pre_point_ != NULL) pre_point_->::hdmap_proto::Point::Clear();
  clear_has_pre_point();
}
inline const ::hdmap_proto::Point& CurveControl::pre_point() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.CurveControl.pre_point)
  return pre_point_ != NULL ? *pre_point_ : *default_instance_->pre_point_;
}
inline ::hdmap_proto::Point* CurveControl::mutable_pre_point() {
  set_has_pre_point();
  if (pre_point_ == NULL) pre_point_ = new ::hdmap_proto::Point;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.CurveControl.pre_point)
  return pre_point_;
}
inline ::hdmap_proto::Point* CurveControl::release_pre_point() {
  clear_has_pre_point();
  ::hdmap_proto::Point* temp = pre_point_;
  pre_point_ = NULL;
  return temp;
}
inline void CurveControl::set_allocated_pre_point(::hdmap_proto::Point* pre_point) {
  delete pre_point_;
  pre_point_ = pre_point;
  if (pre_point) {
    set_has_pre_point();
  } else {
    clear_has_pre_point();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.CurveControl.pre_point)
}

// required .hdmap_proto.Point suc_point = 3;
inline bool CurveControl::has_suc_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CurveControl::set_has_suc_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CurveControl::clear_has_suc_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CurveControl::clear_suc_point() {
  if (suc_point_ != NULL) suc_point_->::hdmap_proto::Point::Clear();
  clear_has_suc_point();
}
inline const ::hdmap_proto::Point& CurveControl::suc_point() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.CurveControl.suc_point)
  return suc_point_ != NULL ? *suc_point_ : *default_instance_->suc_point_;
}
inline ::hdmap_proto::Point* CurveControl::mutable_suc_point() {
  set_has_suc_point();
  if (suc_point_ == NULL) suc_point_ = new ::hdmap_proto::Point;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.CurveControl.suc_point)
  return suc_point_;
}
inline ::hdmap_proto::Point* CurveControl::release_suc_point() {
  clear_has_suc_point();
  ::hdmap_proto::Point* temp = suc_point_;
  suc_point_ = NULL;
  return temp;
}
inline void CurveControl::set_allocated_suc_point(::hdmap_proto::Point* suc_point) {
  delete suc_point_;
  suc_point_ = suc_point;
  if (suc_point) {
    set_has_suc_point();
  } else {
    clear_has_suc_point();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.CurveControl.suc_point)
}

// -------------------------------------------------------------------

// Curve

// repeated .hdmap_proto.CurveControl controls = 1;
inline int Curve::controls_size() const {
  return controls_.size();
}
inline void Curve::clear_controls() {
  controls_.Clear();
}
inline const ::hdmap_proto::CurveControl& Curve::controls(int index) const {
  // @@protoc_insertion_point(field_get:hdmap_proto.Curve.controls)
  return controls_.Get(index);
}
inline ::hdmap_proto::CurveControl* Curve::mutable_controls(int index) {
  // @@protoc_insertion_point(field_mutable:hdmap_proto.Curve.controls)
  return controls_.Mutable(index);
}
inline ::hdmap_proto::CurveControl* Curve::add_controls() {
  // @@protoc_insertion_point(field_add:hdmap_proto.Curve.controls)
  return controls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::CurveControl >&
Curve::controls() const {
  // @@protoc_insertion_point(field_list:hdmap_proto.Curve.controls)
  return controls_;
}
inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::CurveControl >*
Curve::mutable_controls() {
  // @@protoc_insertion_point(field_mutable_list:hdmap_proto.Curve.controls)
  return &controls_;
}

// -------------------------------------------------------------------

// ParkingSlot

// required .hdmap_proto.Id id = 1;
inline bool ParkingSlot::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkingSlot::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkingSlot::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkingSlot::clear_id() {
  if (id_ != NULL) id_->::hdmap_proto::Id::Clear();
  clear_has_id();
}
inline const ::hdmap_proto::Id& ParkingSlot::id() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.ParkingSlot.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::hdmap_proto::Id* ParkingSlot::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::hdmap_proto::Id;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.ParkingSlot.id)
  return id_;
}
inline ::hdmap_proto::Id* ParkingSlot::release_id() {
  clear_has_id();
  ::hdmap_proto::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void ParkingSlot::set_allocated_id(::hdmap_proto::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.ParkingSlot.id)
}

// required .hdmap_proto.Polygon polygon = 2;
inline bool ParkingSlot::has_polygon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParkingSlot::set_has_polygon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParkingSlot::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParkingSlot::clear_polygon() {
  if (polygon_ != NULL) polygon_->::hdmap_proto::Polygon::Clear();
  clear_has_polygon();
}
inline const ::hdmap_proto::Polygon& ParkingSlot::polygon() const {
  // @@protoc_insertion_point(field_get:hdmap_proto.ParkingSlot.polygon)
  return polygon_ != NULL ? *polygon_ : *default_instance_->polygon_;
}
inline ::hdmap_proto::Polygon* ParkingSlot::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) polygon_ = new ::hdmap_proto::Polygon;
  // @@protoc_insertion_point(field_mutable:hdmap_proto.ParkingSlot.polygon)
  return polygon_;
}
inline ::hdmap_proto::Polygon* ParkingSlot::release_polygon() {
  clear_has_polygon();
  ::hdmap_proto::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void ParkingSlot::set_allocated_polygon(::hdmap_proto::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:hdmap_proto.ParkingSlot.polygon)
}

// repeated .hdmap_proto.Id link_ids = 3;
inline int ParkingSlot::link_ids_size() const {
  return link_ids_.size();
}
inline void ParkingSlot::clear_link_ids() {
  link_ids_.Clear();
}
inline const ::hdmap_proto::Id& ParkingSlot::link_ids(int index) const {
  // @@protoc_insertion_point(field_get:hdmap_proto.ParkingSlot.link_ids)
  return link_ids_.Get(index);
}
inline ::hdmap_proto::Id* ParkingSlot::mutable_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:hdmap_proto.ParkingSlot.link_ids)
  return link_ids_.Mutable(index);
}
inline ::hdmap_proto::Id* ParkingSlot::add_link_ids() {
  // @@protoc_insertion_point(field_add:hdmap_proto.ParkingSlot.link_ids)
  return link_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Id >&
ParkingSlot::link_ids() const {
  // @@protoc_insertion_point(field_list:hdmap_proto.ParkingSlot.link_ids)
  return link_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::hdmap_proto::Id >*
ParkingSlot::mutable_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:hdmap_proto.ParkingSlot.link_ids)
  return &link_ids_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdmap_proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_geometry_2eproto__INCLUDED
